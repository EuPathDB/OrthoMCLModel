#!/usr/bin/perl

use strict;

print LOG "Parser parameters and fields:\n";
print LOG "Cutoff parameters:\n\tP value: $pValCutoff\n\tLength: $lengthCutoff\n\tPercent Identity: $percentCutoff\n\n";
print LOG "# Sum: subject_Identifier:score:pvalue:minSubjectStart:maxSubjectEnd:minQueryStart:maxQueryEnd:numberOfMatches:totalMatchLength:numberIdentical:numberPositive:isReversed:readingFrame:non-redundant query match length:non-redundant subject match length:percent of shortest sequence matched\n";
print LOG "#   HSP: subject_Identifier:numberIdentical:numberPositive:matchLength:score:PValue:subjectStart:subjectEnd:queryStart:queryEnd:isReversed:readingFrame\n\n";
 
while (<F>) {
  if (/^\>(\S+)/) {	   ##check to see that this is the accession!!
    &processEntry($cmd, $tmpid, $seq, $program, $tempfile) unless $tmpid eq "";
    $tmpid = $1;
    $seq = "";
  } else {
    $seq .= $_;
  }
}
&processEntry($cmd, $tmpid, $seq, $program, $tempfile) unless $tmpid eq ""; ##do the last one!!

## clean up
close F;
close OUT;
unlink $tempfile;
#stopKillBadBlast() if ($program !~ /rpsblast/);
stopKillBadBlast();
close LOG;

sub processEntry {
  my($cmd, $accession, $sequence, $program, $tempfile) = @_;

  print STDERR "processing $accession\n" if $debug;
  open (TEMPFILE, ">$tempfile") or &error("cannot open temp file $tempfile for writing");
  print TEMPFILE "\>$accession\n$sequence"; 
  close TEMPFILE;

  my ($validOutput, $noHits, @blastn_out, $status);
  my $retry = 2;
  my $try = 1;
  do {
    @blastn_out = `$cmd`;
    $status = $? >> 8;
    ($validOutput, $noHits) = 
      &checkOutput($accession, $program, $status, @blastn_out);
  } while (!$validOutput && ($try++ < $retry));

  if (!$validOutput) {
    if ($doNotExitOnBlastFailure) {
      print OUT "\>$accession (ERROR: BLAST failed ($try times) with status $status)\n";
      return;			##am finished with this one
    } else {
      open(B, ">blast.out");
      print B @blastn_out;
      close(B);
      &error("failed ($try times) with status $status running '$cmd'");
    }
  }
  
  if ($noHits) {
    print OUT "\>$accession (0 subjects)\n" unless $printSimSeqsFile;
  } else {
    &analyzeBlast($accession,@blastn_out);
  }
}

sub checkOutput {
  my ($accession, $program, $status, @blastn_out) = @_;

  my ($validOutput, $noHits);

  if (($status == 16 || $status == 23) && 
      `grep "no valid contexts" blast.stderr`) {    
    print LOG "\>$accession blast failed on low complexity seq\n";
    $validOutput = 1;
    $noHits = 1;
  } elsif ($status == 0 && 
	   (my $res = `grep -A1 -E 'nonnegok|novalidctxok|shortqueryok' blast.stderr` )) {  
    # WUBLAST 2.0 error made non-FATAL by cmdline param
    print LOG "\>$accession blast failed with: $res \n";
    $validOutput = 1;
    $noHits = 1;
  } else {
    foreach my $line (@blastn_out) {
      if ($line =~ /^Sequences producing/) {
	$validOutput = 1;
	$noHits = 0;
	last;
      } elsif (($program =~ /rpsblast/ || $blastVendor eq 'ncbi') && $line =~ /No\shits/) {
	$validOutput = 1;
	$noHits = 1;
	last;
      }
    }
  }
  print LOG "Invalid output for $accession. will retry\n" if !$validOutput;
  return ($validOutput, $noHits);
}

